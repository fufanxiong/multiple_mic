//#include <memory.h>
//#include <curl/curl.h>
#include <stdlib.h>
#include <stdio.h>
#include "FreeRTOS.h"
#include "wifi_conf.h"
#include "flash_api.h"
#include "device_lock.h"

#include "asrmain.h"

#include <FreeRTOS.h>
#include <task.h>
#include <platform_stdlib.h>
#include <httpc/httpc.h>

#include "ttsmain.h"

#include "semphr.h"
#include "osdep_service.h"


const char ASR_SCOPE[] = "audio_voice_assistant_get";
const char API_ASR_URL[] = "http://vop.baidu.com/server_api";


const char API_ASR_SERVER[] = "vop.baidu.com";

const int BUFFER_ERROR_SIZE = 1024;
//char g_demo_error_msg[1024] = {0};
#if 0
#define FLASH_DATA_LEN_CUSTOM		4096

#define FLASH_MIC_ADDR		0x000F5000			//100k space for A_Model
#define MIC_FILE_lEN   129600   //37892
#endif
#define MIC_FILE_lEN   160000   //37892
//#define MIC_FILE_lEN   96000

struct httpc_conn *conn = NULL;
struct asr_config config;
char token[MAX_TOKEN_SIZE];

_sema init_set_tts;

extern char text[512];

extern int one_urlencode_utf_8(unsigned char *code_transfer,unsigned char *des_transfer,int len);

extern void init_queue_to_recv_tts(void);

extern void init_queue_to_recv_parse_mp3(void);

#if 0
char voice_data[] = {
0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x2d ,0x00 ,0x32 ,0x00 ,0x38 ,0x00 ,0x47 ,0x00 ,0x2c ,0x00 ,0x19,		\
0x00 ,0x2e ,0x00 ,0x22 ,0x00 ,0x26 ,0x00 ,0x43 ,0x00 ,0x3d ,0x00 ,0x35 ,0x00 ,0x16 ,0x00 ,0x0b,		\
0x00 ,0x15 ,0x00 ,0x11 ,0x00 ,0x1e ,0x00 ,0x29 ,0x00 ,0x17 ,0x00 ,0x1f ,0x00 ,0x18 ,0x00 ,0x0e,		\
0x00 ,0x15 ,0x00 ,0xfa ,0xff ,0x10 ,0x00 ,0x08 ,0x00 ,0x0e ,0x00 ,0x12 ,0x00 ,0x0d ,0x00 ,0x20,		\
0x00 ,0x1a ,0x00 ,0x27 ,0x00 ,0x0c ,0x00 ,0x2b ,0x00 ,0x34 ,0x00 ,0x34 ,0x00 ,0x37 ,0x00 ,0x24,		\
0x00 ,0x33 ,0x00 ,0x1c ,0x00 ,0x16 ,0x00 ,0x17 ,0x00 ,0x1d ,0x00 ,0x03 ,0x00 ,0x07 ,0x00 ,0x04,		\
0x00 ,0xfd ,0xff ,0x0b ,0x00 ,0x05 ,0x00 ,0x0e ,0x00 ,0x19 ,0x00 ,0x21 ,0x00 ,0x13 ,0x00 ,0x10,		\
0x00 ,0x11 ,0x00 ,0x13 ,0x00 ,0x20 ,0x00 ,0x1d ,0x00 ,0x26 ,0x00 ,0x25 ,0x00 ,0x26 ,0x00 ,0x27,		\
0x00 ,0x26 ,0x00 ,0x22 ,0x00 ,0x26 ,0x00 ,0x21 ,0x00 ,0x23 ,0x00 ,0x20 ,0x00 ,0x16 ,0x00 ,0x0c,		\
0x00 ,0x19 ,0x00 ,0x25 ,0x00 ,0x16 ,0x00 ,0x1c ,0x00 ,0x0d ,0x00 ,0x0c ,0x00 ,0x11 ,0x00 ,0x12,		\
0x00 ,0xfb ,0xff ,0x01 ,0x00 ,0x16 ,0x00 ,0x09 ,0x00 ,0x16 ,0x00 ,0x10 ,0x00 ,0x0a ,0x00 ,0x06,		\
0x00 ,0xf8 ,0xff ,0xf0 ,0xff ,0x13 ,0x00 ,0x0a ,0x00 ,0xed ,0xff ,0x11 ,0x00 ,0xff ,0xff ,0xde,		\
0xff ,0xd8 ,0xff ,0xef ,0xff ,0x08 ,0x00 ,0xf8 ,0xff ,0xee ,0xff ,0xf9 ,0xff ,0xf1 ,0xff ,0xe6,		\
0xff ,0xf2 ,0xff ,0xf6 ,0xff ,0x09 ,0x00 ,0x06 ,0x00 ,0x03 ,0x00 ,0x04 ,0x00 ,0x0d ,0x00 ,0x10,		\
0x00 ,0x18 ,0x00 ,0x21 ,0x00 ,0x14 ,0x00 ,0x20 ,0x00 ,0x12 ,0x00 ,0x01 ,0x00 ,0x05 ,0x00 ,0x19,		\
0x00 ,0x08 ,0x00 ,0x06 ,0x00 ,0x11 ,0x00 ,0x04 ,0x00 ,0x05 ,0x00 ,0x09 ,0x00 ,0x0b ,0x00 ,0x09,		\
0x00 ,0x04 ,0x00 ,0x03 ,0x00 ,0x13 ,0x00 ,0x06 ,0x00 ,0x13 ,0x00 ,0x19 ,0x00 ,0x13 ,0x00 ,0x1d,		\
0x00 ,0x14 ,0x00 ,0x18 ,0x00 ,0x16 ,0x00 ,0x1c ,0x00 ,0x1b ,0x00 ,0x1d ,0x00 ,0x27 ,0x00 ,0x1f,		\
0x00 ,0x1a ,0x00 ,0x2b ,0x00 ,0x25 ,0x00 ,0x25 ,0x00 ,0x2b ,0x00 ,0x29 ,0x00 ,0x21 ,0x00 ,0x0b,		\
0x00 ,0x17 ,0x00 ,0x0e ,0x00 ,0x1d ,0x00 ,0x16 ,0x00 ,0x10 ,0x00 ,0x15 ,0x00 ,0x16 ,0x00 ,0x16,		\
0x00 ,0x0a ,0x00 ,0x1a ,0x00 ,0x16 ,0x00 ,0x14 ,0x00 ,0x13 ,0x00 ,0x1a ,0x00 ,0x0c ,0x00 ,0x10,		\
0x00 ,0x0c ,0x00 ,0x04 ,0x00 ,0x1a ,0x00 ,0x0a ,0x00 ,0x0b ,0x00 ,0x10 ,0x00 ,0x1e ,0x00 ,0x28,		\
0x00 ,0x22 ,0x00 ,0x10 ,0x00 ,0x02 ,0x00 ,0x04 ,0x00 ,0x00 ,0x00 ,0x12 ,0x00 ,0x1b ,0x00 ,0x10,		\
0x00 ,0x02 ,0x00 ,0x10 ,0x00 ,0x0b ,0x00 ,0xff ,0xff ,0x11 ,0x00 ,0x0d ,0x00 ,0x0e ,0x00 ,0x05,		\
0x00 ,0xf3 ,0xff ,0xf3 ,0xff ,0xfa ,0xff ,0x06 ,0x00 ,0x00 ,0x00 ,0xf5 ,0xff ,0xf7 ,0xff ,0xf1,		\
0xff ,0xff ,0xff ,0xf6 ,0xff ,0xf3 ,0xff ,0x01 ,0x00 ,0x03 ,0x00 ,0xf7 ,0xff ,0xf1 ,0xff ,0xfa,		\
0xff ,0xf6 ,0xff ,0x00 ,0x00 ,0xfa ,0xff ,0xf6 ,0xff ,0xf9 ,0xff ,0xf2 ,0xff ,0xf9 ,0xff ,0xfe,		\
0xff ,0xfb ,0xff ,0xff ,0xff ,0x03 ,0x00 ,0x0a ,0x00 ,0x07 ,0x00 ,0x09 ,0x00 ,0x0d ,0x00 ,0x02,		\
0x00 ,0x03 ,0x00 ,0xfa ,0xff ,0xf6 ,0xff ,0xf7 ,0xff ,0xf3 ,0xff ,0xfc ,0xff ,0xfd ,0xff ,0xfc,		\
0xff ,0xf9 ,0xff ,0xf7 ,0xff ,0xfd ,0xff ,0xfd ,0xff ,0xff ,0xff ,0xf6 ,0xff ,0x00 ,0x00 ,0xfd,		\
0xff ,0xf6 ,0xff ,0xfc ,0xff ,0xfd ,0xff ,0xfb ,0xff ,0xf9 ,0xff ,0xf6 ,0xff ,0xf4 ,0xff ,0xf9,		\
0xff ,0xfc ,0xff ,0xf3 ,0xff ,0xfc ,0xff ,0xf8 ,0xff ,0xf1 ,0xff ,0xdf ,0xff ,0xde ,0xff ,0xf3,		\
0xff ,0xed ,0xff ,0xef ,0xff ,0xe3 ,0xff ,0xf0 ,0xff ,0xea ,0xff ,0xd9 ,0xff ,0xe9 ,0xff ,0xea,		\
0xff ,0xe4 ,0xff ,0xdd ,0xff ,0xda ,0xff ,0xce ,0xff ,0xe6 ,0xff ,0xcf ,0xff ,0xc0 ,0xff ,0xcf,		\
0xff ,0xda ,0xff ,0xd2 ,0xff ,0xda ,0xff ,0x03 ,0x00 ,0xf9 ,0xff ,0xe5 ,0xff ,0xe0 ,0xff ,0xf0,		\
0xff ,0xed ,0xff ,0xe7 ,0xff ,0xd4 ,0xff ,0xe4 ,0xff ,0xdc ,0xff ,0xc9 ,0xff ,0xe1 ,0xff ,0xd6,		\
0xff ,0xe4 ,0xff ,0xe5 ,0xff ,0xfd ,0xff ,0xf1 ,0xff ,0xdf ,0xff ,0xe5 ,0xff ,0xd9 ,0xff ,0xef,		\
0xff ,0xec ,0xff ,0xf1 ,0xff ,0xfc ,0xff ,0x08 ,0x00 ,0x06 ,0x00 ,0x0b ,0x00 ,0x05 ,0x00 ,0x05,		\
0x00 ,0xfe ,0xff ,0xee ,0xff ,0xf3 ,0xff ,0x00 ,0x00 ,0x04 ,0x00 ,0xf9 ,0xff ,0x03 ,0x00 ,0xf8,		\
0xff ,0xf5 ,0xff ,0xe8 ,0xff ,0xc9 ,0xff ,0xcc ,0xff ,0xd7 ,0xff ,0xcb ,0xff ,0xde ,0xff ,0xe0,		\
0xff ,0xee ,0xff ,0xe8 ,0xff ,0xed ,0xff ,0x05 ,0x00 ,0x04 ,0x00 ,0x0b ,0x00 ,0x0c ,0x00 ,0x0b,		\
0x00 ,0xf6 ,0xff ,0xf9 ,0xff ,0x02 ,0x00 ,0xf1 ,0xff ,0xd7 ,0xff ,0xe5 ,0xff ,0xe5 ,0xff ,0xdb,		\
0xff ,0xbb ,0xff ,0x9e ,0xff ,0xaf ,0xff ,0xa8 ,0xff ,0xb5 ,0xff ,0xa9 ,0xff ,0x9b ,0xff ,0xb0,		\
0xff ,0xad ,0xff ,0xb6 ,0xff ,0xbd ,0xff ,0xce ,0xff ,0xcd ,0xff ,0xbb ,0xff ,0xc7 ,0xff ,0xc0,		\
0xff ,0xc7 ,0xff ,0xca ,0xff ,0xce ,0xff ,0xec ,0xff ,0xca ,0xff ,0xbb ,0xff ,0xd0 ,0xff ,0xb7,		\
0xff ,0xab ,0xff ,0xb8 ,0xff ,0xa9 ,0xff ,0xc5 ,0xff ,0xcc ,0xff ,0xc2 ,0xff ,0xcd ,0xff ,0xc0,		\
0xff ,0xbd ,0xff ,0xb0 ,0xff ,0xc1 ,0xff ,0xc9 ,0xff ,0xb8 ,0xff ,0xc6 ,0xff ,0xca ,0xff ,0xd3,		\
0xff ,0xce ,0xff ,0xd2 ,0xff ,0xe9 ,0xff ,0xec ,0xff ,0xfe ,0xff ,0xf0 ,0xff ,0xde ,0xff ,0xef,		\
0xff ,0xf3 ,0xff ,0xe0 ,0xff ,0xfc ,0xff ,0x09 ,0x00 ,0xeb ,0xff ,0xed ,0xff ,0xeb ,0xff ,0xfd,		\
0xff ,0x25 ,0x00 ,0x29 ,0x00, 0x09 ,0x00 ,0x21 ,0x00 ,0xfe ,0xff ,0xe4 ,0xff ,0x03 ,0x00 ,0xec,		\
0xff ,0xf7 ,0xff ,0xfb ,0xff ,0x02 ,0x00 ,0xd5 ,0xff ,0xc1 ,0xff ,0xdf ,0xff ,0xd6 ,0xff ,0xfd,		\
0xff ,0x0c ,0x00 ,0xfc ,0xff ,0x02 ,0x00 ,0x18 ,0x00 ,0x2a ,0x00 ,0x28 ,0x00 ,0x2f ,0x00 ,0x3a,		\
0x00 ,0x2b ,0x00 ,0x1a ,0x00 ,0x25 ,0x00 ,0x42 ,0x00 ,0x28 ,0x00 ,0x23 ,0x00 ,0x1c ,0x00 ,0x28,		\
0x00 ,0x28 ,0x00 ,0x30 ,0x00 ,0x27 ,0x00 ,0x0b ,0x00 ,0x27 ,0x00 ,0x1f ,0x00 ,0x16 ,0x00 ,0x04,		\
0x00 ,0x12 ,0x00 ,0x22 ,0x00 ,0x39 ,0x00 ,0x3b ,0x00 ,0x19 ,0x00 ,0x0d ,0x00 ,0x1b ,0x00 ,0x18,		\
0x00 ,0x18 ,0x00 ,0x0b ,0x00 ,0xee ,0xff ,0x04 ,0x00 ,0x0f ,0x00 ,0x16 ,0x00 ,0x12 ,0x00 ,0x13,		\
0x00 ,0x17 ,0x00 ,0x1e ,0x00 ,0x36 ,0x00 ,0x40 ,0x00 ,0x23 ,0x00 ,0x21 ,0x00 ,0x1e ,0x00 ,0x06,		\
0x00 ,0x36 ,0x00 ,0x2c ,0x00 ,0x0d ,0x00 ,0x16 ,0x00 ,0x0e ,0x00 ,0x09 ,0x00 ,0x1d ,0x00 ,0x1e,		\
0x00 ,0x09 ,0x00 ,0x07 ,0x00 ,0xfd ,0xff ,0x08 ,0x00 ,0x08 ,0x00 ,0xfd ,0xff ,0x01 ,0x00 ,0x15,		\
0x00 ,0xf7 ,0xff ,0xec ,0xff ,0xfd ,0xff ,0xfb ,0xff ,0x05 ,0x00 ,0xf6 ,0xff ,0x01 ,0x00 ,0xff,		\
0xff ,0x10 ,0x00 ,0xf8 ,0xff ,0xf1 ,0xff ,0xfc ,0xff ,0xeb ,0xff ,0xf2 ,0xff ,0xe2 ,0xff ,0xf2,		\
0xff ,0xda ,0xff ,0xfa ,0xff ,0xe1 ,0xff ,0xce ,0xff ,0xd4 ,0xff ,0x00 ,0x00 ,0x1c ,0x00 ,0xe8,		\
0xff ,0x14 ,0x00 ,0x15 ,0x00 ,0x08 ,0x00 ,0xec ,0xff ,0x04 ,0x00 ,0x0e ,0x00 ,0x02 ,0x00 ,0x04,		\
0x00 ,0x0a ,0x00 ,0x17 ,0x00 ,0x04 ,0x00 ,0x0b ,0x00 ,0x15 ,0x00 ,0x21 ,0x00 ,0x14 ,0x00 ,0x22		
};
#endif

#if 0
void Upload_file(struct httpc_conn *conn ){
	u32 base_addr;
	flash_t flash;
	int tmp_len,read_len,addr_offset_len=0;
	uint8_t *flash_buffer = (uint8_t *) malloc(FLASH_DATA_LEN_CUSTOM);
	if(flash_buffer == NULL)
	{
		printf("%s malloc failed\n",__func__);
		
	}
    
	tmp_len = MIC_FILE_lEN ;
	base_addr = FLASH_MIC_ADDR;
	
	do{
		if(tmp_len < FLASH_DATA_LEN_CUSTOM)
		{
			read_len = tmp_len;		
		}
		else
		{
			read_len = FLASH_DATA_LEN_CUSTOM;
		}
		
		device_mutex_lock(RT_DEV_LOCK_FLASH);
		flash_stream_read(&flash, base_addr+addr_offset_len, read_len, flash_buffer);
		device_mutex_unlock(RT_DEV_LOCK_FLASH);
		tmp_len -= read_len;
		addr_offset_len += read_len;

		//send firmware
		
		//device_write_spi(&spi_master,flash_buffer,read_len);
		//printf("read flash to send buf[0]=%d,buf[end]=%d\n",flash_buffer[0],flash_buffer[read_len-1]);
		httpc_request_write_data(conn, flash_buffer, read_len);
		
		
	}while(tmp_len > 0);

  if(flash_buffer){	
  	free(flash_buffer);
    flash_buffer=NULL;
  }
  
}
#endif

/**
 * @brief
 * @param config
 */
static RETURN_CODE fill_config(struct asr_config *config) {
    //g_api_key="g8eBUMSokVB1BHGmgxxxxxx"
     char api_key[] = "AIf8O70PGaQeoDAo1MQPbch3";//"4E1BG9lTnlSeIf1NQFlrSq6h";
    //$secretKey="94dc99566550d87f8fa8ece112xxxxx"
     char secret_key[] = "TNqGwiaxkc1tmlwmt2MBxQqH71zahm2w";//"544ca4657ba8002e3dea3ac2f5fdd241";


    char *filename = "16k_test.pcm";
    /*FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        //文件不存在
        snprintf(g_demo_error_msg, BUFFER_ERROR_SIZE,
                 "current running directory does not contain file %s", filename);
        return ERROR_ASR_FILE_NOT_EXIST;
    }*/
 
	
    
    char format[] = "pcm";

    
    int dev_pid = 1537;

    snprintf(config->api_key, sizeof(config->api_key), "%s", api_key);
    snprintf(config->secret_key, sizeof(config->secret_key), "%s", secret_key);
   // config->file = fp;
    snprintf(config->format, sizeof(config->format), "%s", format);
    config->rate = 16000; 
    config->dev_pid = dev_pid;
    snprintf(config->cuid, sizeof(config->cuid), "1234567C");

    return RETURN_OK;
}


/*int main() {
    curl_global_init(CURL_GLOBAL_ALL);
    RETURN_CODE rescode = run();
    curl_global_cleanup();
    if (rescode != RETURN_OK) {
        fprintf(stderr, "ERROR: %s, %d", g_demo_error_msg, rescode);
    }
    return rescode;
}*/


RETURN_CODE run() {
    //struct asr_config config;
    //char token[MAX_TOKEN_SIZE];

    RETURN_CODE res = fill_config(&config);
    if (res == RETURN_OK) {
        res = speech_get_token(config.api_key, config.secret_key, ASR_SCOPE, token);
        if (res == RETURN_OK) {
              printf("\r\n\r\n\r\n>>>>>>>>>>>>>>>get baidu asr<<<<<<<<<<<<<<<<<\r\n\r\n\r\n");
            //run_asr(&config, token);
        }
    }
#if 0
    if (config.file != NULL) {
        //fclose(config.file);
        memset(config.file,0,sizeof(config.file));
        config.file =NULL;
    }
#endif
    return res;
}

int send_head_to_baidu()
{
	run_send_header_to_baidu(&config,token);
	return 0;
}

int  run_send_header_to_baidu(struct asr_config *config, const char *token)
//int  send_header_to_baidu()

{
	char url[128];

	snprintf(url, sizeof(url), "/server_api?cuid=%s&token=%s&dev_pid=%d",
              config->cuid, token, config->dev_pid);
	printf("request url :%s\n", url);

	#if 0//USE_HTTPS
	conn = httpc_conn_new(HTTPC_SECURE_TLS, NULL, NULL, NULL);
    #else
	conn = httpc_conn_new(HTTPC_SECURE_NONE, NULL, NULL, NULL);
    #endif

	if(conn) {

		#if 0//USE_HTTPS
		if(httpc_conn_connect(conn, API_ASR_SERVER, 443, 0) == 0) {
		#else
         
		if(httpc_conn_connect(conn, API_ASR_SERVER, 80, 0) == 0) {
		#endif

          // start a header and add Host (added automatically), Content-Type and Content-Length (added by input param)
			httpc_request_write_header_start(conn, "POST", url, NULL, MIC_FILE_lEN); 
			//httpc_request_write_header_start(conn, "POST", url, NULL, NULL); 
		 
		    httpc_request_write_header(conn, "Connection", "keep-alive");
			
             char header[50];
             snprintf(header, sizeof(header), "audio/%s;rate=%d", config->format,
             config->rate); 
			 printf("header :%s\n",header);
			 httpc_request_write_header(conn, "Content-Type", header);
           

			// finish and send header
			
			httpc_request_write_header_finish(conn);
		}
	}

	return 0;
}

int send_data_to_baidu(char *buf_voice,int voice_len)
{
	//printf("%s ^^\n",__func__);
	httpc_request_write_data(conn, buf_voice, voice_len);
	//printf("%s **\n",__func__);
	return voice_len;
}

int get_result_baidu()
{
	uint8_t buf[1024];
	unsigned char result[MAX_RESULT_SIZE]={0};
	int size;
	RETURN_CODE res = RETURN_OK;

	if(httpc_response_read_header(conn) == 0) {
				httpc_conn_dump_header(conn);

				// receive response body
				if(httpc_response_is_status(conn, "200 OK")) {
                   
						
						int read_size = 0, total_size = 0;

						
						memset(buf, 0, sizeof(buf));
						read_size = httpc_response_read_data(conn, buf, sizeof(buf) - 1);
						
						if(read_size > 0) {
							//total_size += read_size;
							
                            if(buf>0) dbg_printf(":%s", buf);
						   
					      get_json_result(buf, "result",result, &size);
                           
							printf("\n");
							//for(int i=0;i<size;i++)
	                    	//printf("%02x ",result[i]);
 							 
							printf("/%s/",result);
							printf("\n");
							/*set tts*/
							memset(text,0,sizeof(text));
							one_urlencode_utf_8(result,text,size);

							//run start tts
							//run_start_tts();
							rtw_up_sema(&init_set_tts);
						}
				}
				else
					res = ERROR_ASR_CURL;

	}

	 httpc_conn_close(conn);
	 httpc_conn_free(conn);
	return res;
}

#if 0
// 调用识别接口
RETURN_CODE run_asr(struct asr_config *config, const char *token) {
#if 0
    char url[300];
    CURL *curl = curl_easy_init(); // 需要释放
    char *cuid = curl_easy_escape(curl, config->cuid, strlen(config->cuid)); // 需要释放

    snprintf(url, sizeof(url), "%s?cuid=%s&token=%s&dev_pid=%d",
             API_ASR_URL, cuid, token, config->dev_pid);
    free(cuid);
    printf("request url :%s\n", url);

    struct curl_slist *headerlist = NULL;
    char header[50];
    snprintf(header, sizeof(header), "Content-Type: audio/%s; rate=%d", config->format,
             config->rate);
    headerlist = curl_slist_append(headerlist, header); // 需要释放

    int content_len = 0;
    char *result = NULL;
   char *audio_data = read_file_data(config->file, &content_len); // 读取文件， 需要释放
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_POST, 1);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5); // 连接5s超时
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 60); // 整体请求60s超时
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist); // 添加http header Content-Type
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, audio_data); // 音频数据
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, content_len); // 音频数据长度
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &result);  // 需要释放

    CURLcode res_curl = curl_easy_perform(curl);
    RETURN_CODE res = RETURN_OK;
    if (res_curl != CURLE_OK) {
        // curl 失败
        snprintf(g_demo_error_msg, BUFFER_ERROR_SIZE, "perform curl error:%d, %s.\n", res,
                 curl_easy_strerror(res_curl));
        res = ERROR_ASR_CURL;
    } else {
        printf("YOUR FINAL RESULT: %s\n", result);
    }

    curl_slist_free_all(headerlist);
    free(audio_data);
    free(result);
    curl_easy_cleanup(curl);
#else
	char url[128];
	struct httpc_conn *conn = NULL;
	uint8_t buf[1024];
	unsigned char result[MAX_RESULT_SIZE]={0};
	int size;
	RETURN_CODE res = RETURN_OK;
	
	snprintf(url, sizeof(url), "/server_api?cuid=%s&token=%s&dev_pid=%d",
              config->cuid, token, config->dev_pid);
	printf("request url :%s\n", url);

	#if 0//USE_HTTPS
	conn = httpc_conn_new(HTTPC_SECURE_TLS, NULL, NULL, NULL);
    #else
	conn = httpc_conn_new(HTTPC_SECURE_NONE, NULL, NULL, NULL);
    #endif

	if(conn) {

		#if 0//USE_HTTPS
		if(httpc_conn_connect(conn, API_ASR_SERVER, 443, 0) == 0) {
		#else
         
		if(httpc_conn_connect(conn, API_ASR_SERVER, 80, 0) == 0) {
		#endif

          // start a header and add Host (added automatically), Content-Type and Content-Length (added by input param)
			httpc_request_write_header_start(conn, "POST", url, NULL, MIC_FILE_lEN); 
		 
		    httpc_request_write_header(conn, "Connection", "keep-alive");
			
             char header[50];
             snprintf(header, sizeof(header), "audio/%s;rate=%d", config->format,
             config->rate); 
			 printf("header :%s\n",header);
			 httpc_request_write_header(conn, "Content-Type", header);
           

			// finish and send header
			
			httpc_request_write_header_finish(conn);
			// send http body
			Upload_file(conn);
			//httpc_request_write_data(conn, url, strlen(url));
			// receive response header
			if(httpc_response_read_header(conn) == 0) {
				httpc_conn_dump_header(conn);

				// receive response body
				if(httpc_response_is_status(conn, "200 OK")) {
                   
						
						int read_size = 0, total_size = 0;

						
						memset(buf, 0, sizeof(buf));
						read_size = httpc_response_read_data(conn, buf, sizeof(buf) - 1);
						
						if(read_size > 0) {
							//total_size += read_size;
							
                            if(buf>0) dbg_printf(":%s", buf);
							//  ====  获取 result字段 =========
						   
					      get_json_result(buf, "result",result, &size);
                           
							printf("\n");
							for(int i=0;i<size;i++)
	                    	printf("%02x ",result[i]);
 							 
							printf("/%s/",result);
						}
				}
				else
					res = ERROR_ASR_CURL;

			}
		}
     httpc_conn_close(conn);
	 httpc_conn_free(conn);
	 printf("exit\n");
	}


        
	
#endif
	
	return res;
	
    
	
	
}
#endif


void asr_baidu_main(void *param)
{
	// Delay to wait for IP by DHCP
		vTaskDelay(10000);
		printf("\nExample: asr_baidu_main\n");
			while(wifi_is_ready_to_transceive(RTW_STA_INTERFACE) != RTW_SUCCESS){ 
			printf("\r\n\r\n\r\n>>>>>>>>>>>>>>Wifi is disconnected!!Please connect!!<<<<<<<<<<<<<<<<<\r\n\r\n\r\n");
			vTaskDelay(10000);}

     RETURN_CODE rescode = run();
#if 0
	while(1)
	{
		printf("wait state\n");
		vTaskDelay(10000);
	}
#endif
    if (rescode != RETURN_OK) {
       // printf( "ERROR: %s, %d", g_demo_error_msg, rescode);
       printf("fun failed\n");
    }
	else
	{
		printf("run ok\n");
	}

	//init a queue to recv tts
	init_queue_to_recv_tts();

	//enable a mp3 data recv queue
	init_queue_to_recv_parse_mp3();

	while(rtw_down_sema(&init_set_tts) == pdTRUE)
	{
		run_start_tts();
	}
    vTaskDelete(NULL);
}
void baidu_asr(void)
{    
   	printf("in baidu asr\n");
   	rtw_init_sema(&init_set_tts,0);
    if(xTaskCreate(asr_baidu_main, ((const char*)"asr_baidu_main"), 4096, NULL, tskIDLE_PRIORITY +3, NULL) != pdPASS)
        printf("\n\r%s xTaskCreate(init_thread) failed", __FUNCTION__);
}
